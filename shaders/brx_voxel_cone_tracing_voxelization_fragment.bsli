//
// Copyright (C) YuqiaoZhang(HanetakaChou)
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

#ifndef _BRX_VOXEL_CONE_TRACING_VOXELIZATION_FRAGMENT_BSLI_
#define _BRX_VOXEL_CONE_TRACING_VOXELIZATION_FRAGMENT_BSLI_ 1

#ifndef BRX_VCT_ENABLE_ILLUMINATION
#error "0 or 1"
#endif

#include "../../Brioche-Shader-Language/shaders/brx_shader_language.bsli"
#include "../include/brx_voxel_cone_tracing.h"

brx_bool brx_vct_application_bridge_get_surface(in brx_float3 in_normal, in brx_float4 in_tangent, in brx_float2 in_texcoord, out brx_float3 out_surface_shading_normal_world_space, out brx_float3 out_surface_diffuse_color, out brx_float3 out_surface_specular_color, out brx_float out_surface_roughness, out brx_float out_surface_opacity, out brx_float3 out_surface_emissive);

#if BRX_VCT_ENABLE_ILLUMINATION

void brx_vct_application_bridge_get_outgoing_radiances(in brx_float3 in_outgoing_directions_world_space[(brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT))], in brx_float3 in_surface_position_world_space, in brx_float3 in_surface_shading_normal_world_space, in brx_float3 in_surface_emissive, in brx_float3 in_surface_diffuse_color, in brx_float3 in_surface_specular_color, in brx_float in_surface_roughness, out brx_float3 out_outgoing_radiances[(brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT))]);

#endif

brx_uint brx_vct_application_bridge_get_clipmap_mask(in brx_int3 in_mask_texture_coordinates);

brx_uint brx_vct_application_bridge_compare_and_swap_clipmap_mask(in brx_int3 in_mask_texture_coordinates, in brx_uint in_old_value, in brx_uint in_new_value);

#if BRX_VCT_ENABLE_ILLUMINATION

brx_uint brx_vct_application_bridge_get_clipmap_illumination_opacity_red_green(in brx_int3 in_illumination_opacity_texture_coordinates);

brx_uint brx_vct_application_bridge_compare_and_swap_clipmap_illumination_opacity_red_green(in brx_int3 in_illumination_opacity_texture_coordinates, in brx_uint in_old_value, in brx_uint in_new_value);

#endif

brx_uint brx_vct_application_bridge_get_clipmap_illumination_opacity_blue_alpha(in brx_int3 in_illumination_opacity_texture_coordinates);

brx_uint brx_vct_application_bridge_compare_and_swap_clipmap_illumination_opacity_blue_alpha(in brx_int3 in_illumination_opacity_texture_coordinates, in brx_uint in_old_value, in brx_uint in_new_value);

#include "brx_voxel_cone_tracing_resource.bsli"
#include "../../Brioche-Shader-Language/shaders/brx_octahedral_mapping.bsli"

#define INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT 3

// TODO
#define INTERNAL_BRX_VCT_VOXELIZATION_OPACITY_THRESHOLD 1e-4

// TODO
#define INTERNAL_BRX_VCT_VOXELIZATION_ILLUMINATION_THRESHOLD 1e-4

#ifndef INTERNAL_BRX_DISABLE_ROOT_SIGNATURE
brx_root_signature(brx_voxel_cone_tracing_voxelization_root_signature_macro, brx_voxel_cone_tracing_voxelization_root_signature_name)
#endif
brx_pixel_shader_parameter_begin(main)
brx_pixel_shader_parameter_in_sample_mask_in brx_pixel_shader_parameter_split
brx_pixel_shader_parameter_in_frag_coord brx_pixel_shader_parameter_split
brx_pixel_shader_parameter_flat_in(brx_int, in_viewport_depth_direction_index, 0) brx_pixel_shader_parameter_split
brx_pixel_shader_parameter_flat_in(brx_int, in_clipmap_stack_level_index, 1) brx_pixel_shader_parameter_split
brx_pixel_shader_parameter_in(brx_float3, in_interpolated_position_world_space, 2) brx_pixel_shader_parameter_split
brx_pixel_shader_parameter_in(brx_float3, in_interpolated_normal, 3) brx_pixel_shader_parameter_split
brx_pixel_shader_parameter_in(brx_float4, in_interpolated_tangent, 4) brx_pixel_shader_parameter_split
brx_pixel_shader_parameter_in(brx_float2, in_interpolated_texcoord, 5)
brx_pixel_shader_parameter_end(main)
{
    brx_float3 surface_shading_normal_world_space;
    brx_float3 surface_diffuse_color;
    brx_float3 surface_specular_color;
    brx_float surface_roughness;
    brx_float surface_opacity;
    brx_float3 surface_emissive;
    brx_branch if (!brx_vct_application_bridge_get_surface(in_interpolated_normal, in_interpolated_tangent, in_interpolated_texcoord, surface_shading_normal_world_space, surface_diffuse_color, surface_specular_color, surface_roughness, surface_opacity, surface_emissive))
    {
        // discard;
        return;
    }

    brx_float3 surface_position_world_space = in_interpolated_position_world_space;

    // right negative -> right positive
    // up negative -> up positive
    brx_float3 viewport_depth_direction_texel_space = brx_float3(brx_float(BRX_VCT_CLIPMAP_MAP_SIZE) - brx_frag_coord.x, brx_float(BRX_VCT_CLIPMAP_MAP_SIZE) - brx_frag_coord.y, brx_frag_coord.z * BRX_VCT_CLIPMAP_MAP_SIZE);

    brx_float3 texel_space;
    brx_int3 offset_direction;
    brx_branch if (brx_int(BRX_VCT_VIEWPORT_DEPTH_DIRECTION_AXIS_Z) == in_viewport_depth_direction_index)
    {
        texel_space = brx_float3(viewport_depth_direction_texel_space.x, viewport_depth_direction_texel_space.y, viewport_depth_direction_texel_space.z);
        offset_direction = brx_int3(0, 0, 1);
    }
    else if (brx_int(BRX_VCT_VIEWPORT_DEPTH_DIRECTION_AXIS_Y) == in_viewport_depth_direction_index)
    {
        texel_space = brx_float3(viewport_depth_direction_texel_space.y, viewport_depth_direction_texel_space.z, viewport_depth_direction_texel_space.x);
        offset_direction = brx_int3(0, 1, 0);
    }
    else
    {
        // assert(BRX_VCT_VIEWPORT_DEPTH_DIRECTION_AXIS_X == in_viewport_depth_direction_index)
        texel_space = brx_float3(viewport_depth_direction_texel_space.z, viewport_depth_direction_texel_space.x, viewport_depth_direction_texel_space.y);
        offset_direction = brx_int3(1, 0, 0);
    }

    // \[Takeshige 2015\] [Masaya Takeshige. "The Basics of GPU Voxelization." NVIDIA GameWorks Blog 2015.](https://developer.nvidia.com/content/basics-gpu-voxelization)
    // the same pixel may intersect multiple voxels in view depth direction
    // this is the reason why we need to enable the MSAA to check the opacity contribution of each sample, within the same pixel, to different voxels
    const brx_int voxel_coordinates_offsets[INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT] = brx_array_constructor_begin(brx_int, INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT) - 1 brx_array_constructor_split 0 brx_array_constructor_split 1 brx_array_constructor_end;
    brx_float opacity_sample_scale[INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT] = brx_array_constructor_begin(brx_float, INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT) 0.0 brx_array_constructor_split 0.0 brx_array_constructor_split 0.0 brx_array_constructor_end;
    {
        const brx_float viewport_depth_direction_texel_space_relative_z_centers[INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT] = brx_array_constructor_begin(brx_float, INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT) - 0.5 brx_array_constructor_split 0.5 brx_array_constructor_split 1.5 brx_array_constructor_end;

#if 8 == BRX_VCT_VOXELIZATION_PIXEL_SAMPLE_COUNT

#if defined(GL_SPIRV) || defined(VULKAN)
        // "Standard Sample Locations" https://registry.khronos.org/vulkan/specs/1.0/html/chap25.html#primsrast-multisampling
        const brx_float2 sample_positions[BRX_VCT_VOXELIZATION_PIXEL_SAMPLE_COUNT] =
            brx_array_constructor_begin(brx_float2, BRX_VCT_VOXELIZATION_PIXEL_SAMPLE_COUNT)
            brx_float2(0.5625 - 0.5, 0.3125 - 0.5) brx_array_constructor_split
            brx_float2(0.4375 - 0.5, 0.6875 - 0.5) brx_array_constructor_split
            brx_float2(0.8125 - 0.5, 0.5625 - 0.5) brx_array_constructor_split
            brx_float2(0.3125 - 0.5, 0.1875 - 0.5) brx_array_constructor_split
            brx_float2(0.1875 - 0.5, 0.8125 - 0.5) brx_array_constructor_split
            brx_float2(0.0625 - 0.5, 0.4375 - 0.5) brx_array_constructor_split
            brx_float2(0.6875 - 0.5, 0.9375 - 0.5) brx_array_constructor_split
            brx_float2(0.9375 - 0.5, 0.0625 - 0.5)
            brx_array_constructor_end;
#elif defined(HLSL_VERSION) || defined(__HLSL_VERSION)
        // "Standard Sample Patterns" https://learn.microsoft.com/en-us/windows/win32/api/d3d11/ne-d3d11-d3d11_standard_multisample_quality_levels
        const brx_float2 sample_positions[BRX_VCT_VOXELIZATION_PIXEL_SAMPLE_COUNT] =
            brx_array_constructor_begin(brx_float2, BRX_VCT_VOXELIZATION_PIXEL_SAMPLE_COUNT)
            brx_float2(1.0 / 16.0, -3.0 / 16.0) brx_array_constructor_split
            brx_float2(-1.0 / 16.0, 3.0 / 16.0) brx_array_constructor_split
            brx_float2(5.0 / 16.0, 1.0 / 16.0) brx_array_constructor_split
            brx_float2(-3.0 / 16.0, -5.0 / 16.0) brx_array_constructor_split
            brx_float2(-5.0 / 16.0, 5.0 / 16.0) brx_array_constructor_split
            brx_float2(-7.0 / 16.0, -1.0 / 16.0) brx_array_constructor_split
            brx_float2(3.0 / 16.0, 7.0 / 16.0) brx_array_constructor_split
            brx_float2(7.0 / 16.0, -7.0 / 16.0)
            brx_array_constructor_end;
#else
#error Unknown Compiler
#endif

#else
#error
#endif

        // \[Takeshige 2015\] [Masaya Takeshige. "The Basics of GPU Voxelization." NVIDIA GameWorks Blog 2015.](https://developer.nvidia.com/content/basics-gpu-voxelization)
        // "ddx(depth)" and "ddy(depth)" less than 1.0
        brx_float2 delta_z = brx_float2(brx_ddx(viewport_depth_direction_texel_space.z), brx_ddy(viewport_depth_direction_texel_space.z));
        // assert(dZ <= float2(1.0, 1.0))

        brx_float fraction_z = brx_frac(viewport_depth_direction_texel_space.z);

        brx_unroll for (brx_int sample_index = 0; sample_index < brx_int(BRX_VCT_VOXELIZATION_PIXEL_SAMPLE_COUNT); ++sample_index)
        {
            if (0 != brx_int(brx_uint(brx_sample_mask_in) & (1u << brx_uint(sample_index))))
            {
                brx_float relative_z = fraction_z + brx_dot(delta_z, sample_positions[sample_index]);

                brx_unroll for (brx_int voxel_index = 0; voxel_index < brx_int(INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT); ++voxel_index)
                {
                    opacity_sample_scale[voxel_index] += (1.0 / brx_float(BRX_VCT_VOXELIZATION_PIXEL_SAMPLE_COUNT)) * brx_clamp(1.0 - brx_abs(relative_z - viewport_depth_direction_texel_space_relative_z_centers[voxel_index]), 0.0, 1.0);
                }
            }
        }
    }

    brx_float opacity_area_scale;
    {
        brx_float3 geometry_abs_normal = brx_abs(brx_normalize(brx_cross(brx_ddx(texel_space), brx_ddy(texel_space))));
        opacity_area_scale = 1.0 / brx_max((1.0 / brx_sqrt(3.0)), brx_max(geometry_abs_normal.x, brx_max(geometry_abs_normal.y, geometry_abs_normal.z)));
    }

    for (brx_int voxel_index = 0; voxel_index < brx_int(INTERNAL_BRX_VCT_VOXELIZATION_PIXEL_MAXIMUM_VOXEL_COUNT); ++voxel_index)
    {
        brx_int3 voxel_coordinates = brx_int3(texel_space) + offset_direction * voxel_coordinates_offsets[voxel_index];

        brx_float opacity = brx_clamp(surface_opacity * opacity_sample_scale[voxel_index] * opacity_area_scale, 0.0, 1.0);

        brx_branch if ((brx_all(brx_greater_than_equal(voxel_coordinates, brx_int3(0, 0, 0))) && brx_all(brx_less_than(voxel_coordinates, brx_int3(BRX_VCT_CLIPMAP_MAP_SIZE, BRX_VCT_CLIPMAP_MAP_SIZE, BRX_VCT_CLIPMAP_MAP_SIZE)))) && (opacity > brx_float(INTERNAL_BRX_VCT_VOXELIZATION_OPACITY_THRESHOLD)))
        {
            {
                brx_int3 mask_texture_coordinates = internal_brx_get_clipmap_mask_texture_coordinates_int(voxel_coordinates);

                brx_uint value_monotonic_increment = internal_brx_get_clipmap_opacity_mask(in_clipmap_stack_level_index);

                brx_uint old_value;
                brx_uint new_value;
                brx_loop do
                {
                    old_value = brx_vct_application_bridge_get_clipmap_mask(mask_texture_coordinates);

                    new_value = (old_value | value_monotonic_increment);
                }
                while (brx_vct_application_bridge_compare_and_swap_clipmap_mask(mask_texture_coordinates, old_value, new_value) != old_value);
            }

#if BRX_VCT_ENABLE_ILLUMINATION

            // PBR Book V3: [Figure 14.14](https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/The_Light_Transport_Equation#BasicDerivation)
            // PBR Book V4: [Figure 13.1](https://pbr-book.org/4ed/Light_Transport_I_Surface_Reflection/The_Light_Transport_Equation)
            // L_i(ConeApexPosition, ConeDirection) = L_o(VoxelPosition, -ConeDirection)
            //
            // TODO spherical gaussian
            // we view the voxel as 4x4 octahedral map
            //
            // to reduce bandwidth  
            // we only write the opacity to the zeroth index

            brx_float3 outgoing_directions_world_space[(brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT))];
            {
                brx_unroll for (brx_int direction_index = 0; direction_index < (brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT)); ++direction_index)
                {
#if 0 == (BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT & (BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT - 1))
                brx_int direction_width_index = brx_int(brx_uint(direction_index) & brx_uint(brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) - 1));
                brx_int direction_height_index = brx_int(brx_uint(direction_index) >> brx_uint(brx_firstbithigh(brx_uint(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT))));
#else
                    brx_int direction_width_index = brx_int(brx_uint(direction_index) % brx_uint(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT));
                    brx_int direction_height_index = brx_int(brx_uint(direction_index) / brx_uint(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT));
#endif

                    brx_float3 N = surface_shading_normal_world_space;

                    brx_float3 V;
                    {
                        brx_float2 uv = (brx_float2(direction_width_index, direction_height_index) + brx_float2(0.5, 0.5)) / brx_float2(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT, BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT);

                        // PBRT-V4: [File Format](https://www.pbrt.org/users-guide-v4#file_format_changes)
                        // PBRT-V4: [imgtool makeequiarea](https://github.com/mmp/pbrt-v4/blob/master/src/pbrt/cmd/imgtool.cpp#L2130)
                        brx_float2 ndc_flip_x = uv * brx_float2(-2.0, -2.0) + brx_float2(1.0, 1.0);

                        V = brx_octahedral_unmap(ndc_flip_x);
                    }

                    outgoing_directions_world_space[direction_index] = V;
                }
            }

            brx_float3 outgoing_radiances[(brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT))];
            {
                brx_vct_application_bridge_get_outgoing_radiances(outgoing_directions_world_space, surface_position_world_space, surface_shading_normal_world_space, surface_emissive, surface_diffuse_color, surface_specular_color, surface_roughness, outgoing_radiances);
            }

            brx_unroll for (brx_int direction_index = 0; direction_index < (brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT)); ++direction_index)
            {
#if 0 == (BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT & (BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT - 1))
                brx_int direction_width_index = brx_int(brx_uint(direction_index) & brx_uint(brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) - 1));
                brx_int direction_height_index = brx_int(brx_uint(direction_index) >> brx_uint(brx_firstbithigh(brx_uint(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT))));
#else
                brx_int direction_width_index = brx_int(brx_uint(direction_index) % brx_uint(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT));
                brx_int direction_height_index = brx_int(brx_uint(direction_index) / brx_uint(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT));
#endif

                brx_float3 illumination;
                {
                    brx_float3 N = surface_shading_normal_world_space;

                    brx_float3 V = outgoing_directions_world_space[direction_index];

                    brx_float NdotV = brx_dot(N, V);

                    // we move "NdotV > 0.0" to app code

                    // Photon Mapping
                    // L_o(VoxelPosition, VoxelViewDirection) = (1 / ConeBaseDiameter * ConeBaseDiameter) * BRDF * E_n * VoxelSize * VoxelSize
                    // during the voxelization step, we calculate the "BRDF * E_n" part
                    // which happens to be the same as radiance formula in real time rendering
                    brx_float3 brdf_mul_delta_phi_div_voxel_area = outgoing_radiances[direction_index];

                    // [Dunn 2014] [Alex Dunn. "Transparency (or Translucency) Rendering." NVIDIA GameWorks Blog 2014.](https://developer.nvidia.com/content/accumulation_transparency-or-translucency-rendering)
                    // premultiplied alpha color: "BRDF * E_n * VoxelOpacity"
                    // we have to use the "premultiplied alpha color" because the same voxel can be occupied by multiple triangles
                    // but the opacity of each triangle should only contribute to the illumination of the same triangle
                    illumination = brdf_mul_delta_phi_div_voxel_area * opacity;
                }

                brx_branch if (0 == direction_index)
                {
                    brx_branch if (brx_any(brx_greater_than(illumination, brx_float3(INTERNAL_BRX_VCT_VOXELIZATION_ILLUMINATION_THRESHOLD, INTERNAL_BRX_VCT_VOXELIZATION_ILLUMINATION_THRESHOLD, INTERNAL_BRX_VCT_VOXELIZATION_ILLUMINATION_THRESHOLD))))
                    {
                        {
                            brx_int3 mask_texture_coordinates = internal_brx_get_clipmap_mask_texture_coordinates_int(voxel_coordinates);

                            brx_uint value_monotonic_increment = internal_brx_get_clipmap_illumination_mask(direction_width_index, direction_height_index);

                            brx_uint old_value;
                            brx_uint new_value;
                            brx_loop do
                            {
                                old_value = brx_vct_application_bridge_get_clipmap_mask(mask_texture_coordinates);

                                new_value = (old_value | value_monotonic_increment);
                            }
                            while (brx_vct_application_bridge_compare_and_swap_clipmap_mask(mask_texture_coordinates, old_value, new_value) != old_value);
                        }

                        {
                            brx_int3 illumination_opacity_texture_coordinates = internal_brx_get_clipmap_illumination_opacity_texture_coordinates_int(voxel_coordinates, in_clipmap_stack_level_index, direction_width_index, direction_height_index);

                            brx_float2 value_monotonic_increment = brx_float2(illumination.x, illumination.y);

                            brx_uint old_value_packed;
                            brx_uint new_value_packed;
                            brx_loop do
                            {
                                old_value_packed = brx_vct_application_bridge_get_clipmap_illumination_opacity_red_green(illumination_opacity_texture_coordinates);

                                brx_float2 old_value_unpacked = brx_unpack_half2(old_value_packed);

                                brx_float2 new_value_unpacked = old_value_unpacked + value_monotonic_increment;

                                new_value_packed = brx_pack_half2(new_value_unpacked);
                            }
                            while (brx_vct_application_bridge_compare_and_swap_clipmap_illumination_opacity_red_green(illumination_opacity_texture_coordinates, old_value_packed, new_value_packed) != old_value_packed);
                        }
                    }

                    {
                        brx_int3 illumination_opacity_texture_coordinates = internal_brx_get_clipmap_illumination_opacity_texture_coordinates_int(voxel_coordinates, in_clipmap_stack_level_index, direction_width_index, direction_height_index);

                        brx_float2 value_monotonic_increment = brx_float2(illumination.z, opacity);

                        brx_uint old_value_packed;
                        brx_uint new_value_packed;
                        brx_loop do
                        {
                            old_value_packed = brx_vct_application_bridge_get_clipmap_illumination_opacity_blue_alpha(illumination_opacity_texture_coordinates);

                            brx_float2 old_value_unpacked = brx_unpack_half2(old_value_packed);

                            brx_float2 new_value_unpacked = old_value_unpacked + value_monotonic_increment;

                            new_value_packed = brx_pack_half2(new_value_unpacked);
                        }
                        while (brx_vct_application_bridge_compare_and_swap_clipmap_illumination_opacity_blue_alpha(illumination_opacity_texture_coordinates, old_value_packed, new_value_packed) != old_value_packed);
                    }
                }
                else
                {
                    brx_branch if (brx_any(brx_greater_than(illumination, brx_float3(INTERNAL_BRX_VCT_VOXELIZATION_ILLUMINATION_THRESHOLD, INTERNAL_BRX_VCT_VOXELIZATION_ILLUMINATION_THRESHOLD, INTERNAL_BRX_VCT_VOXELIZATION_ILLUMINATION_THRESHOLD))))
                    {
                        {
                            brx_int3 mask_texture_coordinates = internal_brx_get_clipmap_mask_texture_coordinates_int(voxel_coordinates);

                            brx_uint value_monotonic_increment = internal_brx_get_clipmap_illumination_mask(direction_width_index, direction_height_index);

                            brx_uint old_value;
                            brx_uint new_value;
                            brx_loop do
                            {
                                old_value = brx_vct_application_bridge_get_clipmap_mask(mask_texture_coordinates);

                                new_value = (old_value | value_monotonic_increment);
                            }
                            while (brx_vct_application_bridge_compare_and_swap_clipmap_mask(mask_texture_coordinates, old_value, new_value) != old_value);
                        }

                        {
                            brx_int3 illumination_opacity_texture_coordinates = internal_brx_get_clipmap_illumination_opacity_texture_coordinates_int(voxel_coordinates, in_clipmap_stack_level_index, direction_width_index, direction_height_index);

                            {
                                brx_float2 value_monotonic_increment = brx_float2(illumination.x, illumination.y);

                                brx_uint old_value_packed;
                                brx_uint new_value_packed;
                                brx_loop do
                                {
                                    old_value_packed = brx_vct_application_bridge_get_clipmap_illumination_opacity_red_green(illumination_opacity_texture_coordinates);

                                    brx_float2 old_value_unpacked = brx_unpack_half2(old_value_packed);

                                    brx_float2 new_value_unpacked = old_value_unpacked + value_monotonic_increment;

                                    new_value_packed = brx_pack_half2(new_value_unpacked);
                                }
                                while (brx_vct_application_bridge_compare_and_swap_clipmap_illumination_opacity_red_green(illumination_opacity_texture_coordinates, old_value_packed, new_value_packed) != old_value_packed);
                            }

                            {
                                brx_float2 value_monotonic_increment = brx_float2(illumination.z, 0.0);

                                brx_uint old_value_packed;
                                brx_uint new_value_packed;
                                brx_loop do
                                {
                                    old_value_packed = brx_vct_application_bridge_get_clipmap_illumination_opacity_blue_alpha(illumination_opacity_texture_coordinates);

                                    brx_float2 old_value_unpacked = brx_unpack_half2(old_value_packed);

                                    brx_float2 new_value_unpacked = old_value_unpacked + value_monotonic_increment;

                                    new_value_packed = brx_pack_half2(new_value_unpacked);
                                }
                                while (brx_vct_application_bridge_compare_and_swap_clipmap_illumination_opacity_blue_alpha(illumination_opacity_texture_coordinates, old_value_packed, new_value_packed) != old_value_packed);
                            }
                        }
                    }
                }
            }

#else
            {
                brx_int3 illumination_opacity_texture_coordinates = internal_brx_get_clipmap_illumination_opacity_texture_coordinates_int(voxel_coordinates, in_clipmap_stack_level_index, 0, 0);

                brx_float2 value_monotonic_increment = brx_float2(0.0, opacity);

                brx_uint old_value_packed;
                brx_uint new_value_packed;
                brx_loop do
                {
                    old_value_packed = brx_vct_application_bridge_get_clipmap_illumination_opacity_blue_alpha(illumination_opacity_texture_coordinates);

                    brx_float2 old_value_unpacked = brx_unpack_half2(old_value_packed);

                    brx_float2 new_value_unpacked = old_value_unpacked + value_monotonic_increment;

                    new_value_packed = brx_pack_half2(new_value_unpacked);
                }
                while (brx_vct_application_bridge_compare_and_swap_clipmap_illumination_opacity_blue_alpha(illumination_opacity_texture_coordinates, old_value_packed, new_value_packed) != old_value_packed);
            }
#endif
        }
    }

    // discard;
}

#endif
